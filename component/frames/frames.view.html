<section class="section">
    <h1 class="title">Neoan3 Frame</h1>
    <h2 class="subtitle">Settings for your project</h2>
    <p>
        At the heart of Neoan3's ideology is abstraction. Abstraction empowers creators to hone in on an ongoing issue
        without having to review thousands of lines of code that has nothing to do with it. Frames allow for global
        control over the project. Whenever routing in a ctrl.php file, you declare the frame that the component uses.
    </p>

    <h2 class="subtitle has-margin">How to create a frame</h2>
    <p>
        Much like with anything in Neoan3 it's easier to use the neoan3-cli tool. Using the following command will
        generate a new frame:
    </p>
    <code class="code-block">
        neoan3 new frame [frame-name]
    </code>
    <h2 class="subtitle has-margin">How to use a Frame</h2>
    <p>
        The new frame will appear in the "frame" folder in the project. Typically the folder will contain a php file
        with the name that you gave the frame. The file itself will not contain a lot of code in the beginning. With the
        exception of a single empty class extending Serve. While this seems anti-climactic, what is important is that
        your frame has now been set up to serve up information to Neoan3.
    </p>
    <br/>
    <p>
        As an example, let's set up a component named Test.
    </p>
    <pre>
        <code class="code-block">
            namespace Neoan3\Frame;

            use Neoan3\Apps\Ops;
            use Neoan3\Core\Serve;


            class Test extends Serve
            {
                // you can overwrite public methods of \Core\Serve
                function output($params = [])
                {
                    // auto-generate title-tags depending on current route
                    $this->addHead('title',preg_replace('/[A-Z]/',' $0',ucfirst(current_endpoint)));

                    // In most scenarios, you probably want to execute the core's render function
                    parent::output($params);
                }

                function constants()
                {
                    return [
                        'base' => [base],
                        'link' => [
                            [
                                'sizes' => '32x32',
                                'type' => 'image/png',
                                'rel' => 'icon',
                                'href' => 'asset/neoan-favicon.png'
                            ]
                        ],
                        'js' => [
                            ['src' => path .'/frame/test/main.js', 'data' => ['base' => base]]
                        ],
                        'meta'       => [
                            ['name' => 'viewport', 'content' => 'width=device-width, initial-scale=1']
                        ],
                        'stylesheet' => [
                            '' . base . 'frame/test/index.css',
                        ]
                    ];
                }
            }
        </code>
    </pre>
    <p>
        As you see from the above we have set up the component so that way it will not only have the title reflect in
        head tag the name of the component.
        In addition, we've set up a constants function that allows us to set global configuration as an array.
    </p>
    <h3 class="subtitle has-margin">Global configuration</h3>
    <p>
        Instead of using single Core\Serve method calls to set variables,
        one can define configuration variables on the frame-level using an associative array of arrays.
        These arrays are always representations of Core\Serve methods (e.g. 'meta' => Serve->addToHead() ):
    </p>
    <ul>
        <li><a href="#c-js">js</a></li>
        <li><a href="#c-stylesheet">stylesheet</a></li>
        <li><a href="#c-meta">meta & link</a></li>
    </ul>
    <h4 class="subtitle has-margin" id="c-js">js-section</h4>
    <p>
        Each array should have "src" and can have "data" and "type". Using "data" will provide possibility to use the template engine
        to substitute key-value pairs. The result will be rendered into the DOM. Omitting this attribute will lead to an inclusion of the file.
    </p>

    <h4 class="subtitle has-margin" id="c-stylesheet">stylesheet-section</h4>
    <p>
        Accepts an array of stylesheet locations to be included in every execution of a route-component.
    </p>
    <h4 class="subtitle has-margin" id="c-meta">meta-section & link section</h4>
    <p>
        Generates meta- or link-tags using the provided key-value combination(s) as attributes.

    </p>
    <div class="columns">
        <div class="column">
            <p><code>['name' => 'viewport', 'content' => 'width=device-width, initial-scale=1']</code></p>
        </div>
        <div class="column is-narrow">=></div>
        <div class="column"><p><code>&ltmeta name="viewport" content="width=device-width, initial-scale=1"></code></p></div>
    </div>

</section>
